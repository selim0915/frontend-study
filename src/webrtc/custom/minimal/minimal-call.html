<!DOCTYPE html>
<html lang="ko">
<head>
  <script src="/src/webrtc/js/common/set-title.js"></script>
  <script src="/src/webrtc/js/common/utils.js"></script>
  <link rel="stylesheet" href="../../css/main.css">
</head>
<body>
  <h2>Minimal-call</h2>

  <div>
    <div class="row">
      <div class="col">
        <h3>Local</h3>
        <p class="status">상태: <span id="localStatus">-</span></p>
        <video id="localVideo" autoplay playsinline muted></video>
      </div>
      <div class="col">
        <h3>Remote</h3>
        <p class="status">상태: <span id="remoteStatus">-</span></p>
        <video id="remoteVideo" autoplay playsinline></video>
      </div>
    </div>

    <div class="row">
      <button id="startCallBtn" onclick="startCall()" disabled>통화 시작</button>
      <button id="endCallBtn" onclick="endCall()" disabled>통화 종료</button>
      <button id="toggleCameraBtn" onclick="toggleCamera()" disabled>카메라 On</button>
      <button id="toggleAudioBtn" onclick="toggleAudio()" disabled>오디오 On</button>
    </div>
  </div>

  <script>
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');

    const startCallBtn = document.getElementById('startCallBtn');
    const endCallBtn = document.getElementById('endCallBtn');
    const toggleCameraBtn = document.getElementById('toggleCameraBtn');
    const toggleAudioBtn = document.getElementById('toggleAudioBtn');

    const configuration = { iceServers: [] }; // LAN only
    const wssUrl = `wss://192.168.2.95:3001`;

    let pc = null;
    let localStream = null;
    let ws = null;
    let pendingCandidates = [];
    let isCaller = false;
    let callState = 'idle';

    /**
     * 연결 상태 UI 표시시
     */
    function updateUiForState(state) {
      callState = state;
      switch (state) {
        case 'idle':
          startCallBtn.disabled = false;
          endCallBtn.disabled = true;
          toggleCameraBtn.disabled = true;
          toggleAudioBtn.disabled = true;
          break;
        case 'waiting':
        case 'incall':
          startCallBtn.disabled = true;
          endCallBtn.disabled = false;
          toggleCameraBtn.disabled = false;
          toggleAudioBtn.disabled = false;
          break;
      }
    }

    /**
     * peer 객체 생성, MediaStream 준비(remote), ICE candidate 송신 cjfl
     */
    function ensurePC() {
      if (pc) return;
      
      pc = new RTCPeerConnection(configuration);
      pendingCandidates = [];

      const remoteStream = new MediaStream();
      remoteVideo.srcObject = remoteStream;

      /**
       * 상대방이 보낸 audio/video track 수신 핸들러
       * WebRTC는 track 단위로 데이터를 전송하므로
       * 수신된 track을 remoteStream에 추가 → 화면에 표시됨
       */
      pc.ontrack = (event) => {
        if (event.streams && event.streams[0]) {
          event.streams[0].getTracks().forEach((t) => remoteStream.addTrack(t));
        } else if (event.track) {
          remoteStream.addTrack(event.track);
        }
      };

      /**
       * ICE 후보(candidates)가 생성될 때마다 호출되는 핸들러
       * 연결 상대에게 candidate 정보를 WebSocket으로 전송하여
       * NAT Traversal(방화벽 통과)을 가능하게 함
       */
      pc.onicecandidate = (event) => {
        if (event.candidate && ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'candidate', candidate: event.candidate }));
        }
      };

      /**
       * ICE 연결 상태 변화 핸들러
       * - checking    : P2P 연결 시도 중
       * - connected   : P2P 연결 완료
       * - failed      : 연결 실패 (대개 네트워크 문제 or candidate 미수신)
       * - disconnected/closed : 연결 종료
       * 상태에 따라 UI 업데이트 및 통화 종료 처리
       */
      pc.oniceconnectionstatechange = () => {
        console.log('ICE state:', pc.iceConnectionState);

        switch (pc.iceConnectionState) {
          case 'checking':
            applyStatusToDOM('local', 'CONNECTING');
            break;
          case 'connected':
          case 'completed':
            applyStatusToDOM('local', 'CONNECTED');
            applyStatusToDOM('remote', 'CONNECTED');
            updateUiForState('incall');
            break;
          case 'failed':
            applyStatusToDOM('local', 'ERROR', 'ICE 연결 실패');
            endCall();
            break;
          case 'disconnected':
          case 'closed':
            endCall();
            break;
        }
      };
    }

    async function connectWss() {
      return new Promise((resolve, reject) => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          return resolve();
        }

        if (ws && ws.readyState === WebSocket.CONNECTING) {
          ws.addEventListener('open', () => resolve());
          ws.addEventListener('error', (err) => reject(err));
          return;
        }

        try {
          ws = new WebSocket(wssUrl);
          
          ws.onopen = () => {
            console.log('WebSocket connected');

            resolve();
          };
          ws.onclose = () => {
            console.log('WebSocket disconnected');

            ws = null; 
            updateUiForState('idle');
          };
          ws.onerror = (e) => {
            console.error('WS 연결 오류. 인증서 신뢰 또는 네트워크/방화벽을 확인하세요.');

            ws = null;
            updateUiForState('idle');
            reject(e);
          };
    
          ws.onmessage = async (msg) => {
            try {
              const data = JSON.parse(msg.data);

              switch(data.type) {
                case 'offer': {
                  if (callState === 'incall') {
                    console.log('이미 통화 중이라 offer 무시');
                    return;
                  }

                  // signalingState !== 'stable' 이면 충돌 처리
                  if (pc && pc.signalingState !== 'stable') {
                    console.warn('offer collision: local offer 제거 후 incoming offer 처리');
                    await pc.setLocalDescription({ type: 'rollback' });
                  }

                  ensurePC();
                  isCaller = false;

                  await pc.setRemoteDescription(new RTCSessionDescription(data.offer));

                  const answer = await pc.createAnswer();
                  await pc.setLocalDescription(answer);

                  if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'answer', answer: pc.localDescription }));
                  }

                  while (pendingCandidates.length) {
                    const c = pendingCandidates.shift();
                    try { await pc.addIceCandidate(new RTCIceCandidate(c)); } catch(e){ console.warn('addIceCandidate failed', e); }
                  }
                  break;
                }
                case 'answer': {
                  await pc.setRemoteDescription(new RTCSessionDescription(data.answer));

                  while (pendingCandidates.length) {
                    const c = pendingCandidates.shift();
                    try { await pc.addIceCandidate(new RTCIceCandidate(c)); } catch(e){ console.warn('addIceCandidate failed', e); }
                  }
                  break;
                }
                case 'candidate': {
                 if (pc && pc.remoteDescription && pc.remoteDescription.type) {
                    try { await pc.addIceCandidate(new RTCIceCandidate(data.candidate)); }
                    catch(e){ console.warn('addIceCandidate failed', e); }
                  } else {
                    pendingCandidates.push(data.candidate);
                  }
                  break;
                }
                case 'hangup': {
                  endCall();
                  break;
                }
              }
            } catch (e) {
              console.error('WS message handling error:', e);
            }
          };
        } catch (e) {
          console.error('WS 연결 실패: ' + e.message);
          reject(e);
        }
      });
    }
    
    /**
     * 카메라/마이크 권한 요청
     */
    function checkMediaPermissions() {
      const cameraStatus = await navigator.permissions.query({ name: 'camera' });
      const microphoneStatus = await navigator.permissions.query({ name: 'microphone' });

      if (cameraStatus.state === 'denied') throw new Error('카메라 권한을 확인해 주세요.');
      if (microphoneStatus.state === 'denied') throw new Error('마이크 권한을 확인해 주세요.');
    }

    /**
     * 로컬 미디어 장치 연결
     */
    async function getLocalMediaStream() {
      try {
        // 미디어 장치 확인
        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        if (!stream) throw new Error('미디어 장치를 확인해 주세요.');
        localStream = stream;
        localVideo.srcObject = stream;
        
        stream.getTracks().forEach(track => {
          if (!pc.getSenders().find(s => s.track === track)) {
            pc.addTrack(track, stream);
          }
        });
        
        // UX 상태 업데이트
        applyStatusToDOM('local', 'WAITING');
        updateUiForState('waiting');
      } catch (e) {
        throw e;
      }
    }

    /**
     * 통화 시작 이벤트
     */
    async function startCall() {
      try {
        // 권한 확인
        checkMediaPermissions();

        // pc 연결
        ensurePC();

        // 미디어 연결
        await getLocalMediaStream();

        // 소켓 연결
        await connectWss();
        isCaller = true;

        // offer 생성
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'offer', offer: pc.localDescription }));
        }
        
        // UX 상태 업데이트
        applyStatusToDOM('local', 'CONNECTING');
        updateUiForState('waiting');
      } catch (e) {
        // UX 상태 업데이트
        applyStatusToDOM('local', 'ERROR', e.message);
        updateUiForState('idle');
        alert(`${e.message}`);
      }
    }
    
    /**
     * 통화 종료 이벤트
     */
    function endCall() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'hangup' }));
      }

      if (pc) {
        pc.close();
        pc = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;

      applyStatusToDOM('local', 'IDLE');
      applyStatusToDOM('remote', 'IDLE'); 

      updateUiForState('idle');
    }

    function toggleCamera() {
      if (localStream) {
        const videoTrack = localStream.getVideoTracks()[0];
        if (videoTrack) {
          videoTrack.enabled = !videoTrack.enabled;
          toggleCameraBtn.textContent = `카메라 ${videoTrack.enabled ? 'On' : 'Off'}`;
        }
      }
    }

    function toggleAudio() {
      if (localStream) {
        const audioTrack = localStream.getAudioTracks()[0];
        if (audioTrack) {
          audioTrack.enabled = !audioTrack.enabled;
          toggleAudioBtn.textContent = `오디오 ${audioTrack.enabled ? 'On' : 'Off'}`;
        }
      }
    }
    
    window.addEventListener('DOMContentLoaded', () => {
      applyStatusToDOM('local', 'IDLE');
      applyStatusToDOM('remote', 'IDLE');
      updateUiForState('idle');
    });

    window.addEventListener('beforeunload', endCall);
  </script>
</body>
</html>